var documenterSearchIndex = {"docs":
[{"location":"creation/#Creating-this-package","page":"Creating this package","title":"Creating this package","text":"","category":"section"},{"location":"creation/#PkgTemplates","page":"Creating this package","title":"PkgTemplates","text":"","category":"section"},{"location":"creation/","page":"Creating this package","title":"Creating this package","text":"Template:\n  authors: [\"Jeffrey Wack <jeffwack111@gmail.com> and contributors\"]\n  dir: \"~/.julia/dev\"\n  host: \"github.com\"\n  julia: v\"1.11.0\"\n  user: \"jeffwack\"\n  plugins:\n    Citation:\n      file: \"~/.julia/packages/PkgTemplates/5mBnk/templates/CITATION.bib\"\n      readme: true\n    Dependabot:\n      file: \"~/.julia/packages/PkgTemplates/5mBnk/templates/github/dependabot.yml\"\n    Documenter:\n      assets: String[]\n      logo: Logo(nothing, nothing)\n      makedocs_kwargs: Dict{Symbol, Any}()\n      canonical_url: PkgTemplates.github_pages_url\n      make_jl: \"~/.julia/packages/PkgTemplates/5mBnk/templates/docs/make.jlt\"\n      index_md: \"~/.julia/packages/PkgTemplates/5mBnk/templates/docs/src/index.md\"\n      devbranch: nothing\n      edit_link: :devbranch\n    Git:\n      ignore: String[]\n      name: nothing\n      email: \"jeffwack111@gmail.com\"\n      branch: \"main\"\n      ssh: false\n      jl: true\n      manifest: false\n      gpgsign: false\n    GitHubActions:\n      file: \"~/.julia/packages/PkgTemplates/5mBnk/templates/github/workflows/CI.yml\"\n      destination: \"CI.yml\"\n      linux: true\n      osx: true\n      windows: true\n      x64: true\n      x86: true\n      coverage: true\n      extra_versions: [\"1.6\", \"1.11\", \"pre\"]\n    License:\n      path: \"~/.julia/packages/PkgTemplates/5mBnk/templates/licenses/MIT\"\n      destination: \"LICENSE\"\n    ProjectFile:\n      version: v\"1.0.0-DEV\"\n    Readme:\n      file: \"~/.julia/packages/PkgTemplates/5mBnk/templates/README.md\"\n      destination: \"README.md\"\n      inline_badges: false\n      badge_order: DataType[Documenter{GitHubActions}, Documenter{GitLabCI}, Documenter{TravisCI}, GitHubActions, GitLabCI, TravisCI, AppVeyor, DroneCI, CirrusCI, Codecov, Coveralls, BlueStyleBadge, ColPracBadge, PkgEvalBadge]\n      badge_off: DataType[]\n    SrcDir:\n      file: \"~/.julia/packages/PkgTemplates/5mBnk/templates/src/module.jlt\"\n    TagBot:\n      file: \"~/.julia/packages/PkgTemplates/5mBnk/templates/github/workflows/TagBot.yml\"\n      destination: \"TagBot.yml\"\n      trigger: \"JuliaTagBot\"\n      token: Secret(\"GITHUB_TOKEN\")\n      ssh: Secret(\"DOCUMENTER_KEY\")\n      ssh_password: nothing\n      changelog: nothing\n      changelog_ignore: nothing\n      gpg: nothing\n      gpg_password: nothing\n      registry: nothing\n      branches: nothing\n      dispatch: nothing\n      dispatch_delay: nothing\n    Tests:\n      file: \"~/.julia/packages/PkgTemplates/5mBnk/templates/test/runtests.jlt\"\n      project: false\n      aqua: false\n      aqua_kwargs: NamedTuple()\n      jet: false","category":"page"},{"location":"creation/#Github-Pages","page":"Creating this package","title":"Github Pages","text":"","category":"section"},{"location":"creation/","page":"Creating this package","title":"Creating this package","text":"Go to repository settings, deploy from a branch, gh-pages /root.","category":"page"},{"location":"creation/","page":"Creating this package","title":"Creating this package","text":"Now the docs appear on the dev branch. Clicking on the stable badge leads to a 404 error. ","category":"page"},{"location":"creation/#First-release","page":"Creating this package","title":"First release","text":"","category":"section"},{"location":"creation/","page":"Creating this package","title":"Creating this package","text":"I created a release, v1.0, on GitHub. This triggered the CI workflow, which includes a 'Documentation' action. Now the documentation appears on both badges, stable and dev. I then pushed changes to the documentation, which appeared on the dev docs but not stable. From this I conclude the stable docs only update after a release. ","category":"page"},{"location":"tuesday_afternoon/#Dynamics-and-QuantumOptics.jl-Stefan-Krastanov","page":"Schrodinger and Lindblad evolution","title":"Dynamics and QuantumOptics.jl - Stefan Krastanov","text":"","category":"section"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"This package should be thought of as a domain specific linear algebra wrapper.","category":"page"},{"location":"tuesday_afternoon/#Operator-basics","page":"Schrodinger and Lindblad evolution","title":"Operator basics","text":"","category":"section"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"using QuantumOpticsBase\n\ncutoff = 25\n\nF = FockBasis(cutoff)\n\nΨ = fockstate(F,5)","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"S = SpinBasis(1//2)\ns = spindown(S)","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"G = GenericBasis(100)\nbasisstate(G,2)","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"C = F ⊗ S\n\nsparse(dm(Ψ⊗s))\n","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"projector(Ψ⊗s)","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"using BenchmarkTools\nP = projector(Ψ)\nPs = sparse(P)\n\n@benchmark P*Ψ","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"@benchmark Ps*Ψ","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"We can use in-place or mutating functions to improve performance. This is one of the first things to think about optimizing when looking for speedups.","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"using LinearAlgebra: mul!\n\nbuffer = copy(Ψ)\n@benchmark mul!(buffer, Ps, Ψ)","category":"page"},{"location":"tuesday_afternoon/#Composite-spaces","page":"Schrodinger and Lindblad evolution","title":"Composite spaces","text":"","category":"section"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"We can create composite spaces and operators with the '\\otimes' symbol representing the tensor product.","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"psi = fockstate(F,4)⊗spinup(S)","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"create(F)⊗identityoperator(S)","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"This does not scale well! We have a function called embed to address this problem","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"embed(F⊗S, 1, create(F))","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"We can take a partial trace with ptrace()","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"l = spindown(S)\nh = spinup(S)\n\nbell = (l⊗l + h⊗h) / √2\n\nptrace(bell,2)","category":"page"},{"location":"tuesday_afternoon/#Coherent-states","page":"Schrodinger and Lindblad evolution","title":"Coherent states","text":"","category":"section"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"using QuantumOptics","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"QuantumOptics depends on DifferentialEquations, so has a much longer precompile time compared to QuantumOpticsBase, which defines the methods for working with quantum states and operators without any time evolution. ","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"We will work with the quantum harmonic oscillator and look at coherent states in phase space.","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"cutoff = 32\nB = FockBasis(cutoff)\nω = 1.0\na = destroy(B)\n\nH = ω*a'*a","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"Now we can make a coherent state","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"α = 4\nψ = coherentstate(B, α)","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"a*ψ ≈ α*ψ","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"TODO: what is going wrong here?","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"using CairoMakie\nquad = -10:0.1:10\n\nw = wigner(ψ,quad,quad)\n\nfig = Figure()\nax = Axis(fig[1,1], aspect = DataAspect())\nheatmap!(quad,quad,w)\nfig","category":"page"},{"location":"tuesday_afternoon/#Schrodinger-dynamics","page":"Schrodinger and Lindblad evolution","title":"Schrodinger dynamics","text":"","category":"section"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"ts = 0:0.1:3*2*π\n\n_, ψs = timeevolution.schroedinger(ts,ψ,H)\n\nnothing #hide","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"x = (a' + a)/√2\np = 1im*(a' - a)/√2\n\nfig = Figure()\nax = Axis(fig[1,1], aspect = DataAspect())\nlines!(ax,ts,real.(expect.((x,),ψs)))\nlines!(ax,ts,real.(expect.((p,),ψs)))\nfig","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"lines(norm.(ψs))","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"First, the naive way to create a time-dependent Hamiltonian","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"function Hdynamic(t,psi)\n    return H+p*4*sin(8*ω*t)\nend\n\n_, ψs = timeevolution.schroedinger_dynamic(ts,ψ,Hdynamic)\n\nfig = Figure()\nax = Axis(fig[1,1], aspect = DataAspect())\nlines!(ax,ts,real.(expect.((x,),ψs)))\nlines!(ax,ts,real.(expect.((p,),ψs)))\nfig","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"SciMLOperators has an interesting way to create time-dependent operators in an allocation-efficient way.","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"using BenchmarkTools\nHlazy = H + TimeDependentSum(t-> 4*sin(8*ω*t),p)\n@benchmark _, ψs = timeevolution.schroedinger_dynamic(ts, ψ, Hlazy)","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"And the old way:","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"@benchmark _, ψs = timeevolution.schroedinger_dynamic(ts,ψ,Hdynamic)","category":"page"},{"location":"tuesday_afternoon/#Trying-out-different-solvers","page":"Schrodinger and Lindblad evolution","title":"Trying out different solvers","text":"","category":"section"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"using OrdinaryDiffEqLowOrderRK: DP5\nusing OrdinaryDiffEqTsit5: Tsit5\nusing OrdinaryDiffEqVerner: Vern8","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"A good discussion on Schrodinger dynamics and solver tolerance","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"@benchmark _, ψs = timeevolution.schroedinger_dynamic(ts, ψ, Hlazy; alg =\nDP5())","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"@benchmark _, ψs = timeevolution.schroedinger_dynamic(ts, ψ, Hlazy; alg =\nTsit5())","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"@benchmark _, ψs = timeevolution.schroedinger_dynamic(ts, ψ, Hlazy; alg =\nVern8())","category":"page"},{"location":"tuesday_afternoon/#Master-equation-evolution","page":"Schrodinger and Lindblad evolution","title":"Master equation evolution","text":"","category":"section"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"γ = 0.1\n_, ρs = timeevolution.master(ts,ψ,H,[√γ*a])\n\nfig = Figure()\nax = Axis(fig[1,1], aspect = DataAspect())\nlines!(ax,ts,real.(expect.((x,),ρs)))\nlines!(ax,ts,real.(expect.((p,),ρs)))\nfig","category":"page"},{"location":"tuesday_afternoon/","page":"Schrodinger and Lindblad evolution","title":"Schrodinger and Lindblad evolution","text":"TODO: Lindblad is nonlinear with respect to collapse operators? ","category":"page"},{"location":"tuesday_morning/#Introduction-to-state-vector-simulation","page":"Applying operators to quantum states","title":"Introduction to state vector simulation","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"In this lesson, we're going to implement a simple state vector simulator and steadily made it less simple (and more performant) as a way to examine some performance guidelines for Julia and numerical physics.","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"First, let's remind ourselves of some basic facts about state vectors.","category":"page"},{"location":"tuesday_morning/#State-vectors,-gates,-and-observables","page":"Applying operators to quantum states","title":"State vectors, gates, and observables","text":"","category":"section"},{"location":"tuesday_morning/#State-vector-basics","page":"Applying operators to quantum states","title":"State vector basics","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"A state vector is a length-D^N complex vector representing probability amplitudes for a quantum system of N particles, each with D possible states. So, for qubits, which have 2 possible states (0rangle and 1rangle), the state vector has 2^N elements, and for qutrits, which have 3 possible states, the state vector would have 3^N elements.","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"In this lecture we'll focus entirely on the qubit case, as it's most common.","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"For just a single qubit, we have a 2-element vector:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"psi_1rangle = beginbmatrix psi_0  psi_1 endbmatrix","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"Where this corresponds to ","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"psi_1rangle = psi_0  0 rangle + psi_1  1 rangle","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"For two qubits, we have a 4-element vector:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"psi_2rangle = beginbmatrix psi_00  psi_01  psi_10  psi_11 endbmatrix","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"Where this corresponds to","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"psi_2rangle = psi_00  00 rangle + psi_01  01 rangle + psi_10  10 rangle + psi_11  11 rangle","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"For N qubits, the state vector has 2^N elements. We can think of the index within the vector as corresponding to a base-2 representation of the computational basis. So for a vector with index i, we have the state irangle = i_N-1  i_0rangle.","category":"page"},{"location":"tuesday_morning/#Gate-application","page":"Applying operators to quantum states","title":"Gate application","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"Gates are unitary matrices that transform state vectors. For a single qubit system, gates are 2 times 2 matrices. For an N-qubit system, gates are 2^N times 2^N matrices.","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"In Julia, we'll represent our single-qubit gates as follows:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"using LinearAlgebra\nusing Chairmarks\nusing Profile\nusing AliasTables","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"const X = float.(complex.([0 1; 1 0]))\nconst Y = float.([0 -im; im 0])\nconst Z = float.(complex.([1 0; 0 -1]))\nconst I = float.(complex.([1 0; 0 1]))\nconst H = float.(complex.(1/√2 * [1 1; 1 -1]))","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"Most quantum gates act on a single qubit, but the state vector involves many qubits. We can extend a single-qubit gate to act on the entire state vector by taking a tensor product with the identity matrix for all other qubits.","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"For example, if we have a 3-qubit state vector and we want to apply gate G to the second qubit (qubit 1), we need to apply I otimes G otimes I to the state vector. In Julia, the tensor product is implemented as kron.","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"function apply_gate_naive(ψ::Vector, gate::Matrix, gate_qubit::Int)\n    n_qubits  = Int( log2(length(ψ)) )\n    all_gates = [I for qubit in 1:n_qubits]\n    all_gates[n_qubits - gate_qubit] = gate # Julia is one indexed!\n    full_gate = reduce(kron, all_gates)\n    return full_gate * ψ\nend","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"Let's test this with a simple example. We'll create a 3-qubit state vector and apply an X gate to the second qubit:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Create a 3-qubit state vector in the |000⟩ state\nψ = zeros(ComplexF64, 8)\nψ[1] = 1.0  # |000⟩ corresponds to index 1","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Apply X gate to qubit 1 (second qubit)\nψ_new = apply_gate_naive(ψ, X, 1)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# This should give us |010⟩, which corresponds to index 3\nfindall(x -> abs(x) > 1e-10, ψ_new)","category":"page"},{"location":"tuesday_morning/#Observables","page":"Applying operators to quantum states","title":"Observables","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"Observables are Hermitian matrices that correspond to measurable quantities. For a single qubit, common observables are the Pauli matrices X, Y, and Z.","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"The expectation value of an observable O on a state vector psirangle is:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"langle O rangle = langle psi  O  psi rangle","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"For a multi-qubit system, we need to extend the observable to act on the entire state vector using tensor products, just like we did for gates.","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"function expectation_value_naive(ψ::Vector, observable::Matrix, observable_qubit::Int)\n    n_qubits  = Int( log2(length(ψ)) )\n    all_observables = [I for qubit in 1:n_qubits]\n    all_observables[n_qubits - observable_qubit] = observable\n    full_observable = reduce(kron, all_observables)\n    return real(ψ' * full_observable * ψ)\nend","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"Let's test this with our X gate example:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Expectation value of Z on qubit 1 for |000⟩\nexpectation_value_naive(ψ, Z, 1)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Expectation value of Z on qubit 1 for |010⟩\nexpectation_value_naive(ψ_new, Z, 1)","category":"page"},{"location":"tuesday_morning/#Performance-considerations","page":"Applying operators to quantum states","title":"Performance considerations","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"The naive approach works, but it's not very efficient. The main problem is that we're creating a large matrix (2^N times 2^N) for each gate application, which becomes prohibitively expensive for large systems.","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"Let's create a larger system to see the performance issues:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"n_qubits = 8\nψ_large = zeros(ComplexF64, 2^n_qubits)\nψ_large[1] = 1.0","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# This will be slow and memory-intensive\n@b apply_gate_naive(ψ_large, X, 4)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"For a 16-qubit system, we need to create a 65536 times 65536 matrix, which uses about 34 GB of memory! This is clearly not sustainable.","category":"page"},{"location":"tuesday_morning/#Optimized-approaches","page":"Applying operators to quantum states","title":"Optimized approaches","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"The key insight is that we don't need to create the full matrix. Instead, we can directly manipulate the state vector using more efficient algorithms.","category":"page"},{"location":"tuesday_morning/#Approach-1:-Tensor-reshaping","page":"Applying operators to quantum states","title":"Approach 1: Tensor reshaping","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"One approach is to reshape the state vector into a tensor and apply gates more efficiently:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"function apply_gate_reshaped1(ψ::Vector{ComplexF64}, gate::Matrix{ComplexF64}, gate_qubit::Int)\n    n_qubits = Int(log2(length(ψ)))\n    \n    # Reshape the state vector into a tensor\n    tensor_shape = ntuple(i -> 2, n_qubits)\n    ψ_tensor = reshape(ψ, tensor_shape)\n    \n    # Apply the gate to the specified qubit\n    result = similar(ψ_tensor)\n    \n    # We need to contract the gate with the appropriate tensor dimension\n    # This is a simplified version - full implementation would be more complex\n    \n    return vec(result)\nend","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"A more direct approach is to use the structure of the tensor product:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"function apply_gate_reshaped2(ψ::Vector{ComplexF64}, gate::Matrix{ComplexF64}, gate_qubit::Int)\n    n_qubits = Int(log2(length(ψ)))\n    \n    # Create a copy of the state vector\n    ψ_new = copy(ψ)\n    \n    # The key insight is that we can operate on chunks of the state vector\n    chunk_size = 2^gate_qubit\n    stride = 2^(gate_qubit + 1)\n    \n    for i in 1:chunk_size:length(ψ)\n        # Apply the gate to this chunk\n        if i + chunk_size - 1 <= length(ψ)\n            # Get the two components for this qubit\n            α = ψ[i:i+chunk_size-1]\n            β = ψ[i+chunk_size:min(i+stride-1, length(ψ))]\n            \n            # Apply the gate\n            ψ_new[i:i+chunk_size-1] = gate[1,1] * α + gate[1,2] * β\n            if i + stride - 1 <= length(ψ)\n                ψ_new[i+chunk_size:i+stride-1] = gate[2,1] * α + gate[2,2] * β\n            end\n        end\n    end\n    \n    return ψ_new\nend","category":"page"},{"location":"tuesday_morning/#Approach-2:-Bit-manipulation","page":"Applying operators to quantum states","title":"Approach 2: Bit manipulation","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"A more efficient approach uses bit manipulation to directly compute which elements of the state vector need to be modified:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"function apply_gate_shifting1(ψ::Vector{ComplexF64}, gate::Matrix{ComplexF64}, gate_qubit::Int)\n    n = length(ψ)\n    ψ_new = copy(ψ)\n    \n    for i in 0:(n-1)\n        # Check if the gate_qubit is 0 or 1 in the binary representation of i\n        if (i >> gate_qubit) & 1 == 0\n            # The qubit is 0, so we need to find the corresponding 1 state\n            j = i | (1 << gate_qubit)  # Set the gate_qubit to 1\n            \n            # Apply the gate\n            α = ψ[i+1]  # +1 because Julia is 1-indexed\n            β = ψ[j+1]\n            \n            ψ_new[i+1] = gate[1,1] * α + gate[1,2] * β\n            ψ_new[j+1] = gate[2,1] * α + gate[2,2] * β\n        end\n    end\n    \n    return ψ_new\nend","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"Let's test this implementation:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"ψ_test = zeros(ComplexF64, 8)\nψ_test[1] = 1.0","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Apply X gate to qubit 1\nψ_result = apply_gate_shifting1(ψ_test, X, 1)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Compare with naive implementation\nψ_naive = apply_gate_naive(ψ_test, X, 1)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Check if they're the same\nmaximum(abs.(ψ_result - ψ_naive))","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"Great! Now let's benchmark the performance:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"@b apply_gate_shifting1(ψ_large, X, 4)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"This is much faster than the naive approach! But we can do even better.","category":"page"},{"location":"tuesday_morning/#Optimized-bit-manipulation","page":"Applying operators to quantum states","title":"Optimized bit manipulation","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"We can optimize the bit manipulation approach by eliminating redundant work:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"function apply_gate_shifting2(ψ::Vector{ComplexF64}, gate::Matrix{ComplexF64}, gate_qubit::Int)\n    n = length(ψ)\n    ψ_new = copy(ψ)\n    \n    mask = 1 << gate_qubit\n    \n    for i in 0:(n-1)\n        if (i & mask) == 0  # Only process when the target qubit is 0\n            j = i | mask    # Corresponding index with target qubit = 1\n            \n            α = ψ[i+1]\n            β = ψ[j+1]\n            \n            ψ_new[i+1] = gate[1,1] * α + gate[1,2] * β\n            ψ_new[j+1] = gate[2,1] * α + gate[2,2] * β\n        end\n    end\n    \n    return ψ_new\nend","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"@b apply_gate_shifting2(ψ_large, X, 4)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"We can make this even more efficient by using vectorized operations:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"function apply_gate_shifting_linear(ψ::Vector{ComplexF64}, gate::Matrix{ComplexF64}, gate_qubit::Int)\n    n = length(ψ)\n    ψ_new = copy(ψ)\n    \n    # Create masks for efficient bit manipulation\n    mask = 1 << gate_qubit\n    \n    # Process in chunks to utilize vectorization\n    chunk_size = 2^(gate_qubit + 1)\n    lower_chunk = 2^gate_qubit\n    \n    for start in 0:chunk_size:(n-1)\n        # Process the chunk\n        for i in start:(start + lower_chunk - 1)\n            if i + lower_chunk < n\n                j = i + lower_chunk\n                \n                α = ψ[i+1]\n                β = ψ[j+1]\n                \n                ψ_new[i+1] = gate[1,1] * α + gate[1,2] * β\n                ψ_new[j+1] = gate[2,1] * α + gate[2,2] * β\n            end\n        end\n    end\n    \n    return ψ_new\nend","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"@b apply_gate_shifting_linear(ψ_large, X, 4)","category":"page"},{"location":"tuesday_morning/#Threading-for-additional-performance","page":"Applying operators to quantum states","title":"Threading for additional performance","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"For very large systems, we can use threading to parallelize the computation:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"function apply_gate_threaded(ψ::Vector{ComplexF64}, gate::Matrix{ComplexF64}, gate_qubit::Int)\n    n = length(ψ)\n    ψ_new = copy(ψ)\n    \n    chunk_size = 2^(gate_qubit + 1)\n    lower_chunk = 2^gate_qubit\n    \n    Threads.@threads for start in 0:chunk_size:(n-1)\n        for i in start:(start + lower_chunk - 1)\n            if i + lower_chunk < n\n                j = i + lower_chunk\n                \n                α = ψ[i+1]\n                β = ψ[j+1]\n                \n                ψ_new[i+1] = gate[1,1] * α + gate[1,2] * β\n                ψ_new[j+1] = gate[2,1] * α + gate[2,2] * β\n            end\n        end\n    end\n    \n    return ψ_new\nend","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"@b apply_gate_threaded(ψ_large, X, 4)","category":"page"},{"location":"tuesday_morning/#Performance-comparison","page":"Applying operators to quantum states","title":"Performance comparison","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"Let's compare all our implementations:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"println(\"Naive approach:\")\n@b apply_gate_naive(ψ_large, X, 4)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"println(\"Bit shifting approach:\")\n@b apply_gate_shifting_linear(ψ_large, X, 4)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"println(\"Threaded approach:\")\n@b apply_gate_threaded(ψ_large, X, 4)","category":"page"},{"location":"tuesday_morning/#Expectation-values","page":"Applying operators to quantum states","title":"Expectation values","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"We can apply similar optimizations to expectation value calculations:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"function expectation_value_optimized(ψ::Vector{ComplexF64}, observable::Matrix{ComplexF64}, observable_qubit::Int)\n    n = length(ψ)\n    result = 0.0\n    \n    chunk_size = 2^(observable_qubit + 1)\n    lower_chunk = 2^observable_qubit\n    \n    for start in 0:chunk_size:(n-1)\n        for i in start:(start + lower_chunk - 1)\n            if i + lower_chunk < n\n                j = i + lower_chunk\n                \n                α = ψ[i+1]\n                β = ψ[j+1]\n                \n                # Compute the expectation value contribution\n                result += real(conj(α) * observable[1,1] * α + \n                              conj(α) * observable[1,2] * β +\n                              conj(β) * observable[2,1] * α + \n                              conj(β) * observable[2,2] * β)\n            end\n        end\n    end\n    \n    return result\nend","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Test the optimized expectation value\nexpectation_value_optimized(ψ_large, Z, 4)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Compare with naive implementation\nexpectation_value_naive(ψ_large, Z, 4)","category":"page"},{"location":"tuesday_morning/#Multi-qubit-gates","page":"Applying operators to quantum states","title":"Multi-qubit gates","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"For multi-qubit gates (like CNOT), we need to extend our approach:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"function apply_cnot(ψ::Vector{ComplexF64}, control_qubit::Int, target_qubit::Int)\n    n = length(ψ)\n    ψ_new = copy(ψ)\n    \n    control_mask = 1 << control_qubit\n    target_mask = 1 << target_qubit\n    \n    for i in 0:(n-1)\n        # Only apply if control qubit is 1\n        if (i & control_mask) != 0\n            # Find the index with target qubit flipped\n            j = i ⊻ target_mask  # XOR flips the target bit\n            \n            # Swap the amplitudes\n            ψ_new[i+1] = ψ[j+1]\n            ψ_new[j+1] = ψ[i+1]\n        end\n    end\n    \n    return ψ_new\nend","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Test CNOT gate\nψ_cnot_test = zeros(ComplexF64, 4)\nψ_cnot_test[3] = 1.0  # |10⟩ state","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Apply CNOT with control=1, target=0\nψ_cnot_result = apply_cnot(ψ_cnot_test, 1, 0)","category":"page"},{"location":"tuesday_morning/#Sampling-from-quantum-states","page":"Applying operators to quantum states","title":"Sampling from quantum states","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"Often in quantum simulation, we need to sample from the probability distribution defined by the state vector:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"function naive_sample(ψ::Vector{ComplexF64}, n_shots::Int)\n    probabilities = abs2.(ψ)\n    samples = Int[]\n    \n    for _ in 1:n_shots\n        r = rand()\n        cumulative = 0.0\n        \n        for (i, p) in enumerate(probabilities)\n            cumulative += p\n            if r <= cumulative\n                push!(samples, i-1)  # Convert to 0-indexed\n                break\n            end\n        end\n    end\n    \n    return samples\nend","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Test sampling\nsamples = naive_sample(ψ_large, 1000)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Count the frequency of each outcome\nusing StatsBase\ncountmap(samples)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"For better performance with many samples, we can use the alias method:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"function alias_sample(ψ::Vector{ComplexF64}, n_shots::Int)\n    probabilities = abs2.(ψ)\n    \n    # Create alias table\n    alias_table = AliasTables.AliasTable(probabilities)\n    \n    # Sample from the alias table\n    samples = [rand(alias_table) - 1 for _ in 1:n_shots]  # Convert to 0-indexed\n    \n    return samples\nend","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Test alias sampling\nalias_samples = alias_sample(ψ_large, 1000)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Compare performance\n@b naive_sample(ψ_large, 1000)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"@b alias_sample(ψ_large, 1000)","category":"page"},{"location":"tuesday_morning/#Mixed-states-and-density-matrices","page":"Applying operators to quantum states","title":"Mixed states and density matrices","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"For mixed states, we need to work with density matrices instead of state vectors:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"function apply_gate_density_matrix(ρ::Matrix{ComplexF64}, gate::Matrix{ComplexF64}, gate_qubit::Int)\n    n_qubits = Int(log2(size(ρ, 1)))\n    \n    # Create the full gate matrix\n    all_gates = [I for qubit in 1:n_qubits]\n    all_gates[n_qubits - gate_qubit] = gate\n    full_gate = reduce(kron, all_gates)\n    \n    # Apply the gate: ρ_new = U * ρ * U†\n    return full_gate * ρ * full_gate'\nend","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Create a mixed state (50% |0⟩ and 50% |1⟩)\nρ_mixed = zeros(ComplexF64, 2, 2)\nρ_mixed[1,1] = 0.5  # |0⟩⟨0|\nρ_mixed[2,2] = 0.5  # |1⟩⟨1|","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Apply Hadamard gate\nρ_mixed_h = apply_gate_density_matrix(ρ_mixed, H, 0)","category":"page"},{"location":"tuesday_morning/#Putting-it-all-together:-Circuit-simulation","page":"Applying operators to quantum states","title":"Putting it all together: Circuit simulation","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"Let's create a simple function to simulate a quantum circuit:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"function simulate_circuit(initial_state::Vector{ComplexF64}, gates::Vector{Tuple{Matrix{ComplexF64}, Int}})\n    ψ = copy(initial_state)\n    \n    for (gate, qubit) in gates\n        ψ = apply_gate_shifting_linear(ψ, gate, qubit)\n    end\n    \n    return ψ\nend","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Create a Bell state circuit: H on qubit 1, then CNOT(1,0)\ninitial_state = zeros(ComplexF64, 4)\ninitial_state[1] = 1.0  # |00⟩\n\n# Define the circuit\ncircuit = [(H, 1)]  # Apply H to qubit 1","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Run the first part of the circuit\nψ_after_h = simulate_circuit(initial_state, circuit)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Now apply CNOT manually (since we need a specialized function)\nbell_state = apply_cnot(ψ_after_h, 1, 0)","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Verify this is a Bell state\nprintln(\"Bell state amplitudes:\")\nfor (i, amp) in enumerate(bell_state)\n    if abs(amp) > 1e-10\n        println(\"State |$(bitstring(i-1)[end-1:end])⟩: \", amp)\n    end\nend","category":"page"},{"location":"tuesday_morning/#Performance-profiling","page":"Applying operators to quantum states","title":"Performance profiling","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"Let's profile our optimized gate application to see where time is spent:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Profile the optimized gate application\nProfile.clear()\n@profile for i in 1:1000\n    apply_gate_shifting_linear(ψ_large, X, 4)\nend","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"# Display profiling results\nProfile.print()","category":"page"},{"location":"tuesday_morning/#Final-thoughts","page":"Applying operators to quantum states","title":"Final thoughts","text":"","category":"section"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"This tutorial has shown how to implement efficient quantum state vector simulation in Julia. Key takeaways:","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"Avoid creating large matrices: Use bit manipulation instead of tensor products\nVectorize operations: Process data in chunks when possible\nUse threading: For large systems, parallel processing can provide significant speedups\nProfile your code: Use Julia's profiling tools to identify bottlenecks\nConsider specialized algorithms: For sampling, use techniques like the alias method","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"The optimized implementations we've developed can handle reasonably large quantum systems (up to ~20-25 qubits) efficiently, making them suitable for many quantum algorithm simulations and educational purposes.","category":"page"},{"location":"tuesday_morning/","page":"Applying operators to quantum states","title":"Applying operators to quantum states","text":"For production quantum simulation, you would typically use specialized libraries like Yao.jl or PennyLane.jl, but understanding these fundamental algorithms helps you use such libraries more effectively and debug performance issues.","category":"page"},{"location":"monday/#Intro-to-Julia","page":"Julia and linear algebra","title":"Intro to Julia","text":"","category":"section"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"Julia Intro for QNumerics Summer School by Raye Kimmerer.","category":"page"},{"location":"monday/#Other-resources","page":"Julia and linear algebra","title":"Other resources","text":"","category":"section"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"Julia cheat sheet","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"Modern Julia Workflows","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"Performant Serial Julia","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"What scientists must know about hardware to write fast code","category":"page"},{"location":"monday/#Linear-Algebra","page":"Julia and linear algebra","title":"Linear Algebra","text":"","category":"section"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"LinearAlgebra docs","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"using LinearAlgebra\nusing SparseArrays\nusing InteractiveUtils\n\nA = rand(100,100)","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"Transpose and other operations are non-allocating, and instead create a wrapper of the original array. This prevents unecessary allocation and allows more  opportunity to dispatch on array types.","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"B = transpose(A)","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"C = copy(B)","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"When we copy the array it allocates and is no longer a wrapper","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"Diagonal(A)","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"subtypes(LinearAlgebra.Factorization)","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"issymmetric(A*A')","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"How do we communicate this to the dispatch system?","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"D = Symmetric(A*A')","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"Now we can dispatch on the fact that this matrix is symmetric, allowing us to select more efficient algorithms for this case.","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"Symmetric(A)","category":"page"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"This is 'casting' to a symmetric matrix, it will happily create a symmetric matrix out of a non-symmetric one.","category":"page"},{"location":"monday/#Sparse-Arrays","page":"Julia and linear algebra","title":"Sparse Arrays","text":"","category":"section"},{"location":"monday/","page":"Julia and linear algebra","title":"Julia and linear algebra","text":"A = sprand(100,100,0.1)","category":"page"},{"location":"#QNumerics2025","page":"Home","title":"QNumerics2025","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Created at QNumerics2025.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tuesday_evening/#Quantum-trajectories","page":"Monte Carlo wave function evolution","title":"Quantum trajectories","text":"","category":"section"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"Claim: you should not use master equation solvers. You don't pay the exponential cost when working with classical probability distributions, instead we use Monte Carlo simulations. How can we do the same with quantum systems?","category":"page"},{"location":"tuesday_evening/#Good-resources","page":"Monte Carlo wave function evolution","title":"Good resources","text":"","category":"section"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"QuantumOptics documentation","category":"page"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"QuTiP documentation","category":"page"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"Mølmer, Castin, and Dalibard","category":"page"},{"location":"tuesday_evening/#Monte-Carlo-wavefunction-in-QuantumOptics.jl","page":"Monte Carlo wave function evolution","title":"Monte Carlo wavefunction in QuantumOptics.jl","text":"","category":"section"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"using QuantumOptics\n\ncutoff = 32\nB = FockBasis(cutoff)\na = destroy(B)\nω = 1.0\nH = ω*a'*a\n\nγ = 0.1\nL = [√γ*a]\n\nψ = fockstate(B, 18)\n\nts = 0:0.01:3*2*π\n\n_, ρs = timeevolution.master(ts,ψ,H,L)\n\n_, ψs = timeevolution.mcwf(ts,ψ,H,L)\nnothing #hide","category":"page"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"using CairoMakie\nfig = Figure()\nax = Axis(fig[1,1], aspect = DataAspect())\n\nlines!(ax,ts,real.(expect.((a'*a,),ρs)))\nlines!(ax,ts,real.(expect.((a'*a,),ψs)))\n\nfig","category":"page"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"Is the environment photon counting or doing homodyne readout?","category":"page"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"We can make lots of trajectories and average them...","category":"page"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"fig = Figure()\nax = Axis(fig[1,1], aspect = DataAspect())\n\n_, ρs = timeevolution.master(ts,ψ,H,L)\n\nlines!(ax,ts,real.(expect.((a'*a,),ρs)))\n\ntrajectories = []\nn_traj = 100\n\nfor _ in 1:n_traj \n    _, ψs = timeevolution.mcwf(ts,ψ,H,L)\n    push!(trajectories,ψs)\n    lines!(ax,ts,real.(expect.((a'*a,),ψs)), color = (:gray,0.1))\nend\n\nsols_avg = sum([dm.(ψs) for ψs in trajectories])/n_traj\nlines!(ax,ts, real.(expect.((a'*a,), sols_avg)))\n\nfig","category":"page"},{"location":"tuesday_evening/#Cat-states","page":"Monte Carlo wave function evolution","title":"Cat states","text":"","category":"section"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"α = 4.0\n\nl0 = (coherentstate(B,α) + coherentstate(B,-α)) / √2\nl1 = (coherentstate(B,1im*α) + coherentstate(B,-1im*α)) / √2\n\nmix0 = (dm(coherentstate(B,α)) + dm(coherentstate(B,-α))) / 2\nmix1 = (dm(coherentstate(B,1im*α)) + dm(coherentstate(B,-1im*α))) / 2\nnothing #hide\n#TODO: make 4 panel Wigner function plot","category":"page"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"H = ω*a'*a\nts = 0:0.01:π/2\n\n_, ψs = timeevolution.schroedinger(ts,l0,H)\n\nlines(ts, real.(expect.((projector(l0),), ψs)))\nlines!(ts, real.(expect.((projector(l1),), ψs)))\ncurrent_figure()","category":"page"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"We can think of this as a logical gate, it exchanges our two states. ","category":"page"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"We can add loss:","category":"page"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"γ = 0.01\nL = [√γ*a]\n_,ρs = timeevolution.master(ts,l0,H,L);\nlines!(ts, real.(expect.((projector(l0),),ρs)), linestyle=:dash)\nlines!(ts, real.(expect.((projector(l1),),ρs)), linestyle=:dash)\ncurrent_figure()","category":"page"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"We can use non Hermitian time evolution as a worst case analysis. ","category":"page"},{"location":"tuesday_evening/","page":"Monte Carlo wave function evolution","title":"Monte Carlo wave function evolution","text":"Hnotherm = H - im/1 *L[1]'*L[1]\n_,ψnhs = timeevolution.schroedinger(ts,l0,Hnotherm);\nlines!(ts, real.(expect.((projector(l0),),ψnhs)), linestyle=:dot)\nlines!(ts, real.(expect.((projector(l1),),ψnhs)), linestyle=:dot)\ncurrent_figure()","category":"page"}]
}
